
/*  자료형
 char : 문자와 좁은 범위의 숫자, 두가지 방식 사용. 8비트에 맞는 코드를 갖는 모든 문자를 나타낼 수도 있다.
        혼합도 가능 'a' + 7 = 'h' 이런식으로
 short : 덜 좁은 범위를 갖는 정수
 int : 보통 범위를 갖는 정수
 long : 넓은 범위를 갖는 정수
 long long : 아주 넓은 범위를 갖는 정수
 
 unsigned: 위에서 말한 모든 타입의 부호가 없는 버전
 signed: 위에서 말한 모든 타입의 부호가 있는 버전
 float: 단정밀도를 갖는 부동소수점
 double: 배정밀도를 갖는 부동소수점
 long double: 큰 범위를 갖는 부동소수점
 bool: 불 방식, 논리값 (true,false)로 저장
 
 @ c++는 '와 " 를 구분한다. 예를들어 'a'는 char타입이고 "a"는 \0을 포함한 문자열 (char[2])로 생각한다.
 */


/*  상수
    
    c++ 에서 상수는 문법적으로 불변이라는 속성을 갖는 특별한 변수다.
 
    const int a = 2;
    const int a //오류: 값을 할당하지 않으면 안됨. 불변이기에 생성과 동시에 불변속성을 갖고 있어야함.
    const float pi = 3.14159;
    const char cc = 'a';
    const bool cmp = ci1 < ci2;
 
    const 키워드를 통해 다양한 최적화가 가능하며, 타입의 인수로도 사용이 가능하다.
 */

/*  리터럴
    
    리터럴이란 ? int a = 20 <- 리터럴값
    2나 3.14 같은 리터럴도 입력할 수 있다. 간단히 말하자면 정수는 자릿수에 따라 int, long, unsign long타입으로
    취급한다. 소수나 지수는 더블타입으로 취급함.
    다른 리터럴 타입은 접미사를 추가하면된다.
 
    2,  int
    2u, unsined
    2l, long
    2ul, unsigned long
    2.0, double //더블은 안붙이고 소수점만 놓는다.
    2.0f, float
    2.0l, long double
 
    대부분은 묵시적으로 변환해주기 때문에 명시적으로 선언할 필요는 없지만 리터럴의 타입에 주목해야 하는이유가 있다.
    함수들은 서로 다른 인수 타입으로 오버로딩 했을 때, 0과 같은 인수는 애매모호 할수 있지만, 0u와 같이 한정된 인수는
    정확하게 일치하는 타입이 있다.
 
    # 정확도 문제는 long double 타입으로 작업할경우 발생한다. 한정되지 않은 리터럴은 더블타입이기에 롱 더블 타입변수로
    할당하기 전에 자릿수를 잃어 버릴 수 있다.
    long double ld1 = 0.3333333333333333; //자릿수를 잃어버릴것 (더블이기에)
    long double ld2 = 0.3333333333333333l; //정확함
 
    # 10진수가 아닌 다른진수들
    0으로 시작하는 정수는 8진수로 해석한다.
    int a = 042; // 34 (0을 붙였기에 8진수로 인식하여 변환됨)
    int b = 089; //오류 : 8진수는 8이나 9가 없기 때문에 오류발생
 
    # 16진수 리터럴 0x , 0x 접두사 추가
    int a = 0x42; //66
    int b = 0xfa; // 250;
 
    # C++14 에서는 2진수 접두사를 도입했다. 0b접두사 추가
    int a = 0b1111010; // 250
 
    # C++14 에서는 (') 아포스트로피로 긴 숫자를 분리할 수도 있다
    long d = 6'546'687'616'861'129l;
    int b = 0b101'1111'1011'1000'1111;
    
    # string 리터럴
    string s2 = "In c++ better like this";
    매우 긴 텍스트는 여러개의 문자열로 분할가능
    string s2 = "this is a very very long text"
                "that is too too long for one line.";
 */

/*  축소하지 않는 초기화
 
 long 타입의 변수를 큰 숫자로 초기화 한다고 하자.
 long l2 = 1234567890123;
 
 대부분의 64비트 플랫폼에서 long의 크기는 64비트이지만 만약 long크기가 32비트라면 위에있는 값은 너무크다.
 하지만 프로그램은 경고메세지와 함계 여전히 컴파일이 되며, 다른 값이 할당된다. 여기서는 앞쪽 비트가 버려지게 된다.
 c+11은 데이터가 손실되지 않음을 축소되지 않음 을 확인하는 초기화를 도입한다.
 
 long l = { 1234567890123 }; //중괄호안에 있는 값들은 축소가 불가능하다.
 
 축소보호되어 우리에게 값을 초기화 할 때 정밀도를 잃지 않는다는 것을 확인할 수 있게 해준다.
 
 int i1 = 3.14; //값손실되어 컴파일됨
 int i2 = {3.14}; // 축소 오류 : 소수 부분이 사라지게 된다.
 
 unsigned u2 = -3; //값손실되어 컴파일됨
 unsigned u3 = {-3}; //축소 오류 : 음수를 가질 수 없어서 오류냄.
 
 int a = {2};
 unsigned b = {3};
 unsigned c = {a}; //오류 :음수를 가질 수 없음
 int d = {b}; //오류 : 큰 값을 모두 나타낼 수 없음
 @@ singed int와 unsigned int 타입의 크기는 같지만, 각 타입 모든 값은 다르게 표시함.
 */




