
/*  자료형
 char : 문자와 좁은 범위의 숫자, 두가지 방식 사용. 8비트에 맞는 코드를 갖는 모든 문자를 나타낼 수도 있다.
        혼합도 가능 'a' + 7 = 'h' 이런식으로
 short : 덜 좁은 범위를 갖는 정수
 int : 보통 범위를 갖는 정수
 long : 넓은 범위를 갖는 정수
 long long : 아주 넓은 범위를 갖는 정수
 
 unsigned: 위에서 말한 모든 타입의 부호가 없는 버전
 signed: 위에서 말한 모든 타입의 부호가 있는 버전
 float: 단정밀도를 갖는 부동소수점
 double: 배정밀도를 갖는 부동소수점
 long double: 큰 범위를 갖는 부동소수점
 bool: 불 방식, 논리값 (true,false)로 저장
 
 @ c++는 '와 " 를 구분한다. 예를들어 'a'는 char타입이고 "a"는 \0을 포함한 문자열 (char[2])로 생각한다.
 */


/*  상수
    
    c++ 에서 상수는 문법적으로 불변이라는 속성을 갖는 특별한 변수다.
 
    const int a = 2;
    const int a //오류: 값을 할당하지 않으면 안됨. 불변이기에 생성과 동시에 불변속성을 갖고 있어야함.
    const float pi = 3.14159;
    const char cc = 'a';
    const bool cmp = ci1 < ci2;
 
    const 키워드를 통해 다양한 최적화가 가능하며, 타입의 인수로도 사용이 가능하다.
 */

/*  리터럴
    
    리터럴이란 ? int a = 20 <- 리터럴값
    2나 3.14 같은 리터럴도 입력할 수 있다. 간단히 말하자면 정수는 자릿수에 따라 int, long, unsign long타입으로
    취급한다. 소수나 지수는 더블타입으로 취급함.
    다른 리터럴 타입은 접미사를 추가하면된다.
 
    2,  int
    2u, unsined
    2l, long
    2ul, unsigned long
    2.0, double //더블은 안붙이고 소수점만 놓는다.
    2.0f, float
    2.0l, long double
 
    대부분은 묵시적으로 변환해주기 때문에 명시적으로 선언할 필요는 없지만 리터럴의 타입에 주목해야 하는이유가 있다.
    함수들은 서로 다른 인수 타입으로 오버로딩 했을 때, 0과 같은 인수는 애매모호 할수 있지만, 0u와 같이 한정된 인수는
    정확하게 일치하는 타입이 있다.
 
    # 정확도 문제는 long double 타입으로 작업할경우 발생한다. 한정되지 않은 리터럴은 더블타입이기에 롱 더블 타입변수로
    할당하기 전에 자릿수를 잃어 버릴 수 있다.
    long double ld1 = 0.3333333333333333; //자릿수를 잃어버릴것 (더블이기에)
    long double ld2 = 0.3333333333333333l; //정확함
 
    # 10진수가 아닌 다른진수들
    0으로 시작하는 정수는 8진수로 해석한다.
    int a = 042; // 34 (0을 붙였기에 8진수로 인식하여 변환됨)
    int b = 089; //오류 : 8진수는 8이나 9가 없기 때문에 오류발생
 
    # 16진수 리터럴 0x , 0x 접두사 추가
    int a = 0x42; //66
    int b = 0xfa; // 250;
 
    # C++14 에서는 2진수 접두사를 도입했다. 0b접두사 추가
    int a = 0b1111010; // 250
 
    # C++14 에서는 (') 아포스트로피로 긴 숫자를 분리할 수도 있다
    long d = 6'546'687'616'861'129l;
    int b = 0b101'1111'1011'1000'1111;
    
    # string 리터럴
    string s2 = "In c++ better like this";
    매우 긴 텍스트는 여러개의 문자열로 분할가능
    string s2 = "this is a very very long text"
                "that is too too long for one line.";
 */

/*  축소하지 않는 초기화
 
 long 타입의 변수를 큰 숫자로 초기화 한다고 하자.
 long l2 = 1234567890123;
 
 대부분의 64비트 플랫폼에서 long의 크기는 64비트이지만 만약 long크기가 32비트라면 위에있는 값은 너무크다.
 하지만 프로그램은 경고메세지와 함계 여전히 컴파일이 되며, 다른 값이 할당된다. 여기서는 앞쪽 비트가 버려지게 된다.
 c+11은 데이터가 손실되지 않음을 축소되지 않음 을 확인하는 초기화를 도입한다.
 
 long l = { 1234567890123 }; //중괄호안에 있는 값들은 축소가 불가능하다.
 
 축소보호되어 우리에게 값을 초기화 할 때 정밀도를 잃지 않는다는 것을 확인할 수 있게 해준다.
 
 int i1 = 3.14; //값손실되어 컴파일됨
 int i2 = {3.14}; // 축소 오류 : 소수 부분이 사라지게 된다.
 
 unsigned u2 = -3; //값손실되어 컴파일됨
 unsigned u3 = {-3}; //축소 오류 : 음수를 가질 수 없어서 오류냄.
 
 int a = {2};
 unsigned b = {3};
 unsigned c = {a}; //오류 :음수를 가질 수 없음
 int d = {b}; //오류 : 큰 값을 모두 나타낼 수 없음
 @@ singed int와 unsigned int 타입의 크기는 같지만, 각 타입 모든 값은 다르게 표시함.
 */

/*  범위

 범위는 변수와 상수의 수명과 가시성을 결정하고 프로그램 구조를 확립하는 데 기여함.
 
 #전역변수
 전역변수는 모든 함수의 바깥에 선언함. 장점은 코드 어디에서나, 함수 안에서도 참조가능.
 매우 편하다고 생각하겠지만 위험한 잠재력을 지니는 (알수 없는 오류를 몰고다니는..) 변수이다.
 
 만약 전역변수를 사용한다면 조만간 후회하게 될 것. 상수 전역변수는 사이드이펙트가 발생하지 않기에 괜찮음.
 const double pi = 3.141592; // 상수선언 전역변수
 
 #지역변수
 지역변수는 함수 안에서 선언한다. 지역변수의 가시성/가용성은 함수 선언부 {}로 둘러싸인 블록으로 제한됨.
 
 int main()
 {
    {
        const double pi = 3.14159230342343;
    }
    cout << pi << endl; // 오류: pi는 범위 밖에 있음.
 }
 
 #숨기기
 숨기기로 인해 변수들의 수명과 가시성을 구별해보자.
 
 int main()
 {
     int a = 5;
     {
         a = 3;      // a#1 할당. a#2는 아직 없음.
         int a;      // a#2 등장.
         a = 8;      // a#2에 8대입. a#1은 숨겨진다.
         {
             a = 7;  // a#2에 7 대입.
         }
     }
     a = 11;         // a#1에 할당한다. (a#2는 이미 범위 밖이라 없어짐)
     
     return 0;
 }
 범위의 장점은 변수가 범위 바깥 어딘가에 이미 정으되어 있는지에 대한 여부를 걱정하지 않아도됨.
 범위는 단지 숨겨져 있을뿐! 이로인해 충돌이 발생하지 않음. 불행하게도 숨기기는 바깥쪽 범위에 있는 같은 이름의
 변수에 접근 할 수 없음. (숨겨져 있어서) 하지만 네임스페이스를 이용해 해결이 됨.
 
 static 변수는 이 규칙을 따르지 않는다. static 변수는 프로그램이 끝날 때 까지 살아있지만, 범위 안에서만!! 보임
 그게 전역변수와 차이점이다.
 int main()
 {
     int a = 5;
     
     {
         static int a = 10; //이 범위에서만 스태틱이 보여지는 점이 어디든 접근 할 수 있는 전역과 다르다.
         a = 8;
     }
     
     a = 11;
 }

 */


